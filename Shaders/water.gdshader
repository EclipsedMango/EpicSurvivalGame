shader_type spatial;

const float SMOOTHSTEP_AA = 0.01;
uniform sampler2D surfaceNoise;
uniform sampler2D distortNoise;
uniform sampler2D DEPTH_TEXTURE : hint_depth_texture, filter_linear_mipmap;

uniform float beer_factor = 0.8;

uniform float foam_distance = 0.01;
uniform float foam_max_distance = 0.4;
uniform float foam_min_distance = 0.04;
uniform vec4 foam_color: source_color  = vec4(1.0);

uniform vec2 surface_noise_tiling = vec2(1.0, 4.0);
uniform vec3 surface_noise_scroll = vec3(0.03, 0.03, 0.0);
uniform float surface_noise_cutoff: hint_range(0, 1) = 0.777;
uniform float surface_distortion_amount: hint_range(0, 1) = 0.27;

uniform vec4 _DepthGradientShallow: source_color = vec4(0.325, 0.807, 0.971, 0.725);
uniform vec4 _DepthGradientDeep: source_color = vec4(0.086, 0.407, 1, 0.749);
uniform float _DepthMaxDistance: hint_range(0, 1) = 1.0;
uniform float _DepthFactor = 1.0;

varying vec2 noiseUV;
varying vec2 distortUV;
varying vec3 viewNormal;

vec4 alphaBlend(vec4 top, vec4 bottom)
{
	vec3 color = (top.rgb * top.a) + (bottom.rgb * (1.0 - top.a));
	float alpha = top.a + bottom.a * (1.0 - top.a);
	
	return vec4(color, alpha);
}

void vertex() {
	viewNormal = (MODELVIEW_MATRIX * vec4(NORMAL, 0.0)).xyz;
	noiseUV = UV * surface_noise_tiling;
	distortUV = UV;
}

void fragment(){
	// https://www.youtube.com/watch?v=Jq3he9Lbj7M
	float depthVal = texture(DEPTH_TEXTURE, SCREEN_UV).r;
	float depth = PROJECTION_MATRIX[3][2] / (depthVal + PROJECTION_MATRIX[2][2]);
	depth = depth + VERTEX.z;
	depth = exp(-depth * beer_factor);
	depth = 1.0 - depth;
	
	// Still unsure how to get properly the NORMAL from the camera
	// This was generated by ChatGPT xD
    vec4 view_pos = INV_PROJECTION_MATRIX * vec4(SCREEN_UV * 2.0 - 1.0, depthVal, 1.0);
    view_pos /= view_pos.w;
    vec3 existingNormal = normalize(cross( dFdx(view_pos.xyz), dFdy(view_pos.xyz)));

	float normalDot = clamp(dot(existingNormal.xyz, viewNormal), 0.0, 1.0);
	float foamDistance = mix(foam_max_distance, foam_min_distance, normalDot);
	
	float foamDepth = clamp(depth / foamDistance, 0.0, 1.0);
	float surfaceNoiseCutoff = foamDepth * surface_noise_cutoff;
	
	vec4 distortNoiseSample = texture(distortNoise, distortUV);
	vec2 distortAmount = (distortNoiseSample.xy * 2.0 -1.0) * surface_distortion_amount;
	
	vec2 noise_uv = vec2(
		(noiseUV.x + TIME * surface_noise_scroll.x) + distortAmount.x , 
		(noiseUV.y + TIME * surface_noise_scroll.y + distortAmount.y)
	);
	float surfaceNoiseSample = texture(surfaceNoise, noise_uv).r;
	float surfaceNoiseAmount = smoothstep(surfaceNoiseCutoff - SMOOTHSTEP_AA, surfaceNoiseCutoff + SMOOTHSTEP_AA, surfaceNoiseSample);
	
	float waterDepth = clamp(depth / _DepthMaxDistance, 0.0, 1.0) * _DepthFactor;
	vec4 waterColor = mix(_DepthGradientShallow, _DepthGradientDeep, waterDepth);

	vec4 surfaceNoiseColor = foam_color;
    surfaceNoiseColor.a *= surfaceNoiseAmount;
	vec4 color = alphaBlend(surfaceNoiseColor, waterColor);
	
    ALBEDO = color.rgb;
	ALPHA = color.a;
}

//shader_type spatial;
//
//uniform vec3 albedo : source_color;
//uniform vec3 albedo2 : source_color;
//uniform float metallic : hint_range(0.0, 1.0) = 0;
//uniform float roughness : hint_range(0.0, 1.0) = 0.02;
//uniform sampler2D wave;
//uniform sampler2D texture_normal;
//uniform sampler2D texture_normal2;
//uniform vec2 wave_direction = vec2(2.0,0.0); // Direction of wave 1
//uniform vec2 wave_direction2 = vec2(0.0,1.0); // Direction of wave 2
//uniform float time_scale : hint_range(0.0, 0.2, 0.005) = 0.025; // Rate of movement multiplied by TIME
//uniform float noise_scale = 0.5;
//uniform float height_scale = 10.0;
//
//uniform sampler2D DEPTH_TEXTURE : hint_depth_texture, filter_linear_mipmap;
//uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;
//
//uniform vec4 color_deep : source_color; // Deep depth color
//uniform vec4 color_shallow : source_color; // Shallow depth color
//uniform float beers_law = 2.0; // Beer's law application
//uniform float depth_offset = -0.75; // Offset
//
//uniform float edge_scale = 0.1;
//uniform float near = 1.0;
//uniform float far = 100.0;
//uniform vec3 edge_color : source_color;
//
//// Varying variables
//varying float height;
//varying vec3 world_pos;
//
//float fresnel(float amount, vec3 normal, vec3 view) {
	//return pow((1.0 - clamp(dot(normalize(normal), normalize(view)), 0.0, 1.0 )), amount);
//}
//
//float edge(float depth) {
	//depth = 2.0 * depth - 1.0;
	//return near * far / (far + depth * (near - far));
//}
//
//void vertex() {
	//world_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz * 0.05;
	//height = texture(wave, world_pos.xz / noise_scale + TIME * time_scale).r;
	//VERTEX.y += height * height_scale;
//}
//
//void fragment() {
	//// Depth variables and calc
	//float depth_texture = texture(DEPTH_TEXTURE, SCREEN_UV).r * 2.0 - 1.0;
	//float depth = PROJECTION_MATRIX[3][2] / (depth_texture + PROJECTION_MATRIX[2][2]);
	//float depth_blend = exp((depth+VERTEX.z + depth_offset) * -beers_law);
	//depth_blend = clamp(1.0 - depth_blend, 0.0, 1.0);	
	//float depth_blend_power = clamp(pow(depth_blend, 2.5), 0.0, 1.0);
//
	//// Retrieving depth color and applying the deep and shallow colors
	//vec3 screen_color = textureLod(SCREEN_TEXTURE, SCREEN_UV, depth_blend_power * 2.5).rgb;
	//vec3 depth_color = mix(color_shallow.rgb, color_deep.rgb, depth_blend_power);
	//vec3 color = mix(screen_color * depth_color, depth_color * 0.25, depth_blend_power * 0.5);
	//
	//// Getting edge depth calc
	//float z_depth = edge(texture(DEPTH_TEXTURE, SCREEN_UV).x);
	//float z_pos = edge(FRAGCOORD.z);
	//float z_dif = z_depth - z_pos;
	//
	//// Time calculations for wave (normal map) movement
	//vec2 time = (TIME * wave_direction) * time_scale; // Movement rate of first wave
	//vec2 time2 = (TIME * wave_direction2) * time_scale; // Movement rate of second wave
	//
	//// Blend normal maps into one
	//vec3 normal_blend = mix(texture(texture_normal, world_pos.xz + time).rgb, texture(texture_normal2, world_pos.xz + time2).rgb, 0.5);
	//
	//// Calculate Fresnel
	//float fresnel = fresnel(5.0, NORMAL, VIEW);
	//vec3 surface_color = mix(albedo, albedo2, fresnel); // Interpolate albedo values by frensel
	//
	//vec3 depth_color_adj = mix(edge_color, color, step(edge_scale, z_dif));
	//
	//ALBEDO = clamp(surface_color + depth_color_adj,vec3(0.0),vec3(1.0));
	//METALLIC = metallic;
	//ROUGHNESS = roughness * 20.0;
	//NORMAL_MAP = normal_blend;
//}